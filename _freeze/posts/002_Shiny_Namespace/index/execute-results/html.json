{
  "hash": "6941704e25a8d9ed27941fe099a556e7",
  "result": {
    "markdown": "---\ntitle: \"Namespaces in shiny: Why you need them\"\nauthor: \"Giorgio Luciano and ChatGPT\"\ndate: \"2023-09-16\"\ncategories: \n  - R\n  - tutorials\n  - ggplot\n  - shiny\n  - tutorials\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(viridis)  # Import the viridis color palette library\nlibrary(ggplot2)\n\nset.seed(123)  # Set a seed for reproducibility\nnum_flips <- 50000\nflips <- sample(c(\"Heads\", \"Tails\"), num_flips, replace = TRUE)\n\n# Image aspect ratio\naspect_ratio <- 1  # You can customize the aspect ratio here\nn_col <- round(sqrt(num_flips) * aspect_ratio)\nn_row <- ceiling(num_flips / n_col)\n\n# Create a color matrix to represent coin flips\ncolors <- ifelse(flips == \"Heads\", \"red\", \"blue\")\n\n# Create matrices for Heads and Tails\nheads_matrix <- matrix(0, nrow = n_row, ncol = n_col)\ntails_matrix <- matrix(0, nrow = n_row, ncol = n_col)\n\nfor (i in 1:num_flips) {\n  if (flips[i] == \"Heads\") {\n    heads_matrix[(i - 1) %/% n_col + 1, (i - 1) %% n_col + 1] <- 1\n  } else {\n    tails_matrix[(i - 1) %/% n_col + 1, (i - 1) %% n_col + 1] <- 1\n  }\n}\n\n# Function to calculate the number of consecutive sequences\ncalculate_sequences <- function(matrix) {\n  sequences <- matrix(0, nrow = nrow(matrix), ncol = ncol(matrix))\n  for (i in 1:nrow(matrix)) {\n    count <- 0\n    for (j in 1:ncol(matrix)) {\n      if (matrix[i, j] == 1) {\n        count <- count + 1\n        sequences[i, j] <- count\n      } else {\n        count <- 0\n      }\n    }\n  }\n  return(sequences)\n}\n\n# Calculate sequences for Heads and Tails matrices\nsequences_heads <- calculate_sequences(heads_matrix)\nsequences_tails <- calculate_sequences(tails_matrix)\n\n# Find the longest sequence for Heads and Tails\nlongest_sequence_heads <- max(sequences_heads)\nlongest_sequence_tails <- max(sequences_tails)\n\n# Create images with sequences and titles\npar(mfrow = c(1, 2))  # Display the two images side by side\nimage(t(sequences_heads), col = viridis(100), main = paste(\"Heads Sequences (Max:\", longest_sequence_heads, \")\"), xaxt = \"n\", yaxt = \"n\")\nimage(t(sequences_tails), col = inferno(100), main = paste(\"Tails Sequences (Max:\", longest_sequence_tails, \")\"), xaxt = \"n\", yaxt = \"n\")\n\nlibrary(knitr)\n\n# Calculate sequences for Heads and Tails matrices\nsequences_heads <- calculate_sequences(heads_matrix)\nsequences_tails <- calculate_sequences(tails_matrix)\n\n# Calculate sequence lengths for Heads and Tails\nsequence_lengths_heads <- table(sequences_heads)\nsequence_lengths_tails <- table(sequences_tails)\n\n# Calculate the percentage of sequence lengths\npercentages_heads <- prop.table(sequence_lengths_heads) * 100\npercentages_tails <- prop.table(sequence_lengths_tails) * 100\n\n# Create data frames with lengths, absolute numbers, and percentages\ndataframe_heads <- data.frame(\n  Length = names(sequence_lengths_heads),\n  Absolute_Numbers = as.numeric(sequence_lengths_heads),\n  Percentage = percentages_heads\n)\ndataframe_tails <- data.frame(\n  Length = names(sequence_lengths_tails),\n  Absolute_Numbers = as.numeric(sequence_lengths_tails),\n  Percentage = percentages_tails\n)\n\n# Create formatted tables\nkable(dataframe_heads, caption = \"Table of Heads Sequence Lengths\")\nkable(dataframe_tails, caption = \"Table of Tails Sequence Lengths\")\n```\n:::\n\n\nIn this example, both module_1 and module_2 share the same IDs for input elements (text_input and action_button). If we interact with one module, it will affect the other module as well, leading to unexpected behavior.\n\n## Using Namespaces (Recommended)\n\nNow, let's use namespaces to create unique IDs for each module instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nmy_module <- function(id) {\n  ns <- NS(id)\n  tagList(\n    textInput(inputId = ns(\"text_input\"), label = \"Enter text:\"),\n    actionButton(inputId = ns(\"action_button\"), label = \"Click me\")\n  )\n}\n\nui <- fluidPage(\n  my_module(\"module_1\"),\n  my_module(\"module_2\")\n)\n```\n:::\n\n\nIn this example, we use NS to generate unique namespaces for each module instance (module_1 and module_2). As a result, the input element IDs are unique between instances, ensuring that interactions within one module do not affect the other module.\n\n### Conclusion\n\nWhen creating Shiny modules, it's highly recommended to use namespaces (NS) to prevent ID conflicts between module instances. This practice ensures that each module operates independently and avoids unexpected behavior when working with multiple modules in your Shiny app.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}