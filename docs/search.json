[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fun with data",
    "section": "",
    "text": "Tip 1: ggplot loops\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nFeb 19, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\n\n\nTip 2: Cleaning column names of an imported csv\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nFeb 19, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\n\n\nTip 3: Functions for simulating data\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nFeb 19, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a Chemist that works as a researcher at the National Research Council of Italy. I work on characterization of materials and data analysis. I code in Python and R and I like Computer Graphics and Illustration\nAbout this blog\nin this blog I share the code that I write in my everyday work and also fun stuff that I find on other blogs and site about data analytics"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "docs/posts/R Packages/index.html",
    "href": "docs/posts/R Packages/index.html",
    "title": "Fun with Data",
    "section": "",
    "text": "Don’t trust boxplot\n\ncategories: [r,ggplot,recipes]\n\n\n# Author: Giorgio Luciano\n# Title: boxplot fun\n# Date: 16/2/2023\n# Status: checked working\n##---------------------------------------------------------------\n\n# Step 1: Load libraries\n\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(data.table)\nlibrary(RColorBrewer)\nlibrary(ggpubr)\nlibrary(rstatix, warn.conflicts = FALSE)\nlibrary(ggrepel)\nlibrary(ggpubr)\nlibrary(patchwork)\n\n# Step 2: Write a function for generating data with custom number of rows, means and sds\n\nsimpleDataset <- function(number_of_rows, means, sds)\n{\nl <- length( means )\nres <- lapply(seq(1:l),function(x) \n       eval(parse(text=paste(\"rnorm(\",number_of_rows,\",\",means[x],\",\",sds[x],\")\",sep = \"\")))) \ndat <- data.frame((sapply(res,c)))\nid <- rownames(dat)\ndat <-  cbind(id = id,dat)\ndt <- data.table(dat)\nreturn(dt)\n}\n\ndat1 <- simpleDataset(number_of_rows=100,\n                      means = runif(10,100,150),\n                      sds = runif(10,10,40))\n\noutliers <- simpleDataset(number_of_rows=5,\n                      means = runif(10,60,80),\n                      sds = runif(10,10,10))                  \n\ndato     <-rbind(dat1,outliers) \n\ndt.melt <- melt(dat1, id.vars=\"id\")\ncolnames(dt.melt) <- c(\"id\",\"category\",\"var1\")\ndt.melt$ncat <- as.numeric(dt.melt$category)\n\n#Step 3:    Jiitter plots + boxplot + brackets \n\n#setting up dimensions\noptions(repr.plot.width=8.9, repr.plot.height=8.9,units=\"cm\")\n\n#adding jiitter plot\n\np <-  ggplot(dt.melt,aes(x=factor(ncat),y=var1))        +\n      geom_jitter(position = position_jitter(0.15),alpha=0.5,size = 3) +\n      geom_boxplot(alpha = 0,lwd=0.2) \n##---------------------------------------------------------------\n\nSo for now everything on track. We created a dataset using a custom function. 10 variables with 100 points each and them we plot them using scatter plots. Before plotting a few more data we need to answer the question\n*How are boxplot constructed?* (*warning*: shameless self-promotion ahead) First of all you can check on my book/ebook [https://amzn.com/B08W8W5WSF](https://amzn.com/B08W8W5WSF)\nNow it starts the fun part we will recreate a plot on the anatomy of a boxplot (see [here](https://www.sharpsightlabs.com/blog/ggplot-boxplot/)) using ggplot.\n\n# we create a dataset and add a few outliers\n# \ny   <- c(60,63,105,155,rnorm(100,80,25))\nbox <-  ggplot()                                               +\n        theme_void()                                           +\n        geom_boxplot(aes(x=0,y=y),width=1,notch = FALSE,lwd=1) +  \n        theme(legend.position = \"none\")                        +\n        lims( x = c(-2,2) )\n      \n#how can we  get out data? using the function ggplot_build()\n#need to change it to a data.frame and rename cols\n\nbox_data <- (ggplot_build(box)$data)[[1]]\nbox_data\n\n      ymin    lower   middle    upper     ymax outliers notchupper notchlower x\n1 16.81564 58.19611 75.04227 96.32843 130.8743      155   80.95017   69.13436 0\n  flipped_aes PANEL group ymin_final ymax_final xmin xmax xid newx new_width\n1       FALSE     1    -1   16.81564        155 -0.5  0.5   1    0         1\n  weight colour  fill size alpha shape linetype\n1      1 grey20 white    1    NA    19    solid\n\nbdata <- data.frame(t(box_data[c(1,2,3,4,5,14)]))\ncolnames(bdata) <- c(\"y\")\n#we need to transpose the data and convert them to a data frame\n#now we extract the ourliers \noutl  <- data.frame(box_data$outliers)\ncolnames(outl)  <- c(\"outl\")\n\n#now that I got the data I plot everything with labels\np2 <- box + geom_text (data=bdata,aes(\n                      x=1.5,\n                      y=y,\n                      label = c(\"min\",\"Lower Q\",\"Median\",\"Upper Q\",\"max\",\"outliers\")), size = 2)+\n                      geom_segment(data = bdata, aes(x = 0.8, y = y, xend = 0.7, yend = y),lwd=1)  \n                        \n#since we have created the dataset WITH outliers we include labels also for them\n#if your dataset has no outliers you need to commet this part out\n    \np2 + geom_text_repel(data=outl,aes(x=0.1, y=outl,label=format(round(outl, 2), nsmall = 2)),size= 2) \n\n\n\n\n*notes on the code:* we create our variable `y` with `rnorm` and we add a few outliers by hand then we create the boxplot with an empty theme using `theme_void()`. The funny part start when we ask ggplot to show how the plot was built with the `ggplot_build`. We then need to rotate (`t`) the selected columns `c(1,2,3,4,5,14)` ,convert the results into a `data.frame`, rename the columns (`colnames`) and then use them (our `y`) to add labvels to our plot using `geom_text`\nAnother representation of boxplot can also include *notch*. the default is not to visualuize them but just adding `notch=true` to the previous plot we will do the trick\n\nboxnotch <-  ggplot()                                               +\n             theme_void()                                           +\n             geom_boxplot(aes(x=0,y=y),width=1,notch = TRUE,lwd=1)  +  \n             theme(legend.position = \"none\")                        +\n             lims(x=c(-2,4))\nnotchdata <- data.frame(t(box_data[c(7,8)]))\ncolnames(notchdata) <- c(\"y_notch\")\n#we need to transpose the data and convert them to a data frame\n\n#now that I got the data I plot everything with labels\np3 <- boxnotch +  geom_segment(data=notchdata, aes(x = 0.8, \n                                                   y = mean(y_notch),\n                                                   xend = 0.6, yend = y_notch\n                                                   ),lwd=1)\np4 <- p3 + annotate(geom=\"text\", x=2.5, y= mean(notchdata$y_notch),\n                    label=\"notch (95% confidence\\ninterval of median)\",size=4)\np4\n\n\n\n\nok but what if multiple dataset have same statistics? Like in the case of the datasaurus package(Matejka and Fitzmaurice 2017)\n\nlibrary(datasauRus)\n\nWarning: package 'datasauRus' was built under R version 4.2.2\n\nsummary(box_plots)\n\n      left              lines               normal          right       \n Min.   :-9.76964   Min.   :-9.769575   Min.   :-9.76   Min.   :-9.760  \n 1st Qu.:-2.68999   1st Qu.:-2.689993   1st Qu.:-2.68   1st Qu.:-2.680  \n Median :-0.00999   Median :-0.007132   Median : 0.00   Median : 0.000  \n Mean   :-1.17780   Mean   :-0.831733   Mean   : 0.00   Mean   : 1.174  \n 3rd Qu.: 2.67007   3rd Qu.: 2.670236   3rd Qu.: 2.68   3rd Qu.: 2.680  \n Max.   : 9.75025   Max.   : 9.756001   Max.   : 9.76   Max.   : 9.760  \n     split          \n Min.   :-9.769886  \n 1st Qu.:-2.689989  \n Median :-0.003099  \n Mean   :-0.003060  \n 3rd Qu.: 2.680000  \n Max.   : 9.760000  \n\np1 <-ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_jitter(alpha=0.05)                                 +\ntheme_void()  \n\np2 <- ggplot(stack(box_plots), aes(x = ind, y = values))+\ngeom_boxplot(lwd=0.05) +\ntheme_void()  \np1+p2\n\n\n\n\nWe can see that plotting the raw points even for hundreds of points works and represent well our data. In this case adding notch does not solve the problem. Other kind of plot get not fooled by our data as it can be seen in the following figure:\n\npnotch <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_boxplot(notch=TRUE)  +  ggtitle(\"(notch=TRUE)\")\n  \npjitter <-ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_jitter(alpha=0.05)  +  ggtitle(\"geom_jitter\") \n\npviolin <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_violin(lwd=1)  +  ggtitle(\"geom_violin\") \n\npnotch \n\n\n\npjitter \n\n\n\npviolin\n\n\n\n\nOther packages\n1. beeswarm plot ggbeeswarm [https://github.com/eclarke/ggbeeswarm] (and here the things start getting artistic too!) (note: not all representation for this dataset work due to the number of points)\n\nlibrary(ggbeeswarm)\n\nWarning: package 'ggbeeswarm' was built under R version 4.2.2\n\np_qrandom0 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05)  +  ggtitle(\"quasi_random\") \n\n#p_qrandom0\n\np_qrandom1 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukey\")  +  ggtitle(\"Tukey\") \n\n#p_qrandom1\n\np_qrandom2 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukeyDense\")   +  ggtitle(\"Tukey + density\") \n\n#p_qrandom2\n\np_qrandom3 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukeyDense\")   +  ggtitle(\"Banded frowns\") \n\n#p_qrandom3\n\np_qrandom4 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"frowney\")   +  ggtitle(\"Banded smiles\") \n\n#p_qrandom4\n\n#too many points\n#p_beeswarm <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\n#geom_beeswarm(alpha=0.05) +  ggtitle(\"beeswarm\") \n\np_qrandom0\n\n\n\np_qrandom1\n\n\n\np_qrandom2\n\n\n\n\nyou can halso mix plot a useful package for that is gghalves\n\nlibrary(gghalves)\n\nWarning: package 'gghalves' was built under R version 4.2.2\n\npoint_half <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_half_point(alpha=0.05) \n\ngeom_half_violin() \n\ngeom_half_violin: side = l, nudge = 0, draw_quantiles = NULL, na.rm = FALSE\nstat_half_ydensity: trim = TRUE, scale = area, na.rm = FALSE\nposition_dodge \n\npoint_half\n\n\n\n\nfinally a very useful package, also my favorite one for EDA ggstatplotthat you can find here that calculate also a lot of useful stats and combine different kind of plot in one plot\n\nlibrary(ggstatsplot)\n\nYou can cite this package as:\n     Patil, I. (2021). Visualizations with statistical details: The 'ggstatsplot' approach.\n     Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167\n\n\n\nAttaching package: 'ggstatsplot'\n\n\nThe following object is masked from 'package:data.table':\n\n    :=\n\nstackbox <- stack(box_plots)\n\npstack  <- ggbetweenstats(\n  data = stackbox,\n  x = ind,\n  y = values,\n)\npstack \n\n\n\n\n\n\n\n\nReferences\n\nMatejka, Justin, and George Fitzmaurice. 2017. “Same Stats, Different Graphs.” Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems, May. https://doi.org/10.1145/3025453.3025912."
  },
  {
    "objectID": "posts/Tip01/index.html",
    "href": "posts/Tip01/index.html",
    "title": "Tip 1: ggplot loops",
    "section": "",
    "text": "Summary\n\nCreate an empty list\nPopulate your list with objects (ggplots)\nCreate iteratively names for the objects\nRename the objects inside the list using the name list generated previously\nShow all plots using wrap_plots\n\nInstead of using boring plots we will use our private art collections and items.\nOne great package to create your art in R is aRtsy Let’s fire it up\n\nrequire(aRtsy)\n\nLoading required package: aRtsy\n\n\nWarning: package 'aRtsy' was built under R version 4.2.2\n\nrequire(patchwork)\n\nLoading required package: patchwork\n\n\n\n#before starting for having a look at the palette \n?colorPalette\n\nstarting httpd help server ... done\n\n\nCreate a Mondrian and save it\n\nset.seed(23)\nComposition_10 <- canvas_squares(colors = colorPalette(\"boogy2\"))\nsaveCanvas(Composition_10 , filename = \"Mondrian.png\")\nComposition_10 \n\n\n\n\nand another one\n\nset.seed(1)\naspect_ratio <- 1\nheight <- 2\nComposition_1 = canvas_segments(colors = colorPalette(\"blackwhite\"))\nComposition_1 \n\n\n\n\nor if you want to create a lots of them, create names automatically and then take a look at just one of your artistic composition in your collection use the following code:\n\nn_items <- 3\ncollection <- list()\nname_of_Composition  <- list()\nfor (i in 1:n_items) {\n  seed <-  (sample(1:100000,1)) + 1\n  name_of_Composition[[i]] <- paste0(\"Composition_\", i)\n  collection[[i]] <- canvas_squares(colors = colorPalette(\"boogy2\"))\n  \n}\nnames(collection) <- name_of_Composition\n\ncollection\n\n$Composition_1\n\n\n\n\n\n\n$Composition_2\n\n\n\n\n\n\n$Composition_3\n\n\n\n\n\n\n#as you can notice the setting for figure output in this chunk was changed in order to showplots with a rato of 3:1\nwrap_plots(collection)\n\n\n\n\n(Pedersen 2022) [Wickham (2016)](Derks 2022)\n\n\n\n\nReferences\n\nDerks, Koen. 2022. “aRtsy: Generative Art with ’Ggplot2’.” https://CRAN.R-project.org/package=aRtsy.\n\n\nPedersen, Thomas Lin. 2022. “Patchwork: The Composer of Plots.” https://CRAN.R-project.org/package=patchwork.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org."
  },
  {
    "objectID": "posts/Tip02/index.html",
    "href": "posts/Tip02/index.html",
    "title": "Tip 2: Cleaning column names of an imported csv",
    "section": "",
    "text": "Summary\n\nImport data from a csv file\nUse the function clean_names from (Firke 2023)j R function\nWrite a function in base using gsub and regex to tackle specific issues\nYou’re done\n\nFirst of all we import the csv using the library (Müller 2020)here\n\nlibrary(here)\n\nWarning: package 'here' was built under R version 4.2.2\n\n\nhere() starts at D:/giorgioluciano.github.io\n\nfile_in <- \"FakeData.csv\"\npath_in <- \"posts/Tip02/\"\ndata <- read.csv(here(path_in,file_in), head=T, check.names=F, encoding=\"latin1\")\n\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.2.2\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\ndata_fixed <- clean_names(data)\n\nAnd now the function written by William Doane\n\nclinical_names <- function(.data, unique = FALSE) {\n  n <- if (is.data.frame(.data)) colnames(.data) else .data\n  n <- gsub(\"cvrisk\", \"CVrisk\", n , ignore.case=T)\n  n <- gsub(\"hbo\", \"HBO\", n , ignore.case=T)\n  n <- gsub(\"ft4\", \"fT4\", n , ignore.case=T)\n  n <- gsub(\"f_t4\", \"fT4\", n , ignore.case=T)\n  n <- gsub(\"ft3\", \"fT3\", n , ignore.case=T)\n  n <- gsub(\"f_t3\", \"fT3\", n , ignore.case=T)\n  n <- gsub(\"ldl\", \"LDL\", n , ignore.case=T)\n  n <- gsub(\"hdl\", \"HDL\", n , ignore.case=T)\n  n <- gsub(\"hba1c\", \"HbA1C\", n, ignore.case=T)\n  n <- gsub(\"hbac1\", \"HbA1C\", n, ignore.case=T)\n  n <- gsub(\"hb_ac1\", \"HbA1C\",n,ignore.case=T)\n  n <- gsub(\"\\\\igf\\\\b\", \"IGF\", n , ignore.case=T)\n  n <- gsub(\"tsh\", \"TSH\", n , ignore.case=T)\n  n <- gsub(\"acth\", \"ACTH\", n, ignore.case=T)\n  n <- gsub(\"\\\\Na\\\\b\", \"Sodio\", n)\n  n <- gsub(\"\\\\K\\\\b\",  \"Potassio\", n)\n  n <- gsub(\"\\\\P\\\\b\",  \"Fosforo\", n)\n  n <- gsub(\"\\\\pas\\\\b\", \"PAS\", n, ignore.case=T)\n  n <- gsub(\"\\\\pad\\\\b\", \"PAD\", n, ignore.case=T)\n  n <- gsub(\"\\\\pth\\\\b\", \"PTH\", n, ignore.case=T)\n  n <- gsub(\"\\\\clu\\\\b\", \"CLU\", n, ignore.case=T)\n  n <- gsub(\"\\\\tg\\\\b\", \"TG\", n, ignore.case=T)\n  n <- gsub(\"\\\\glic\\\\b\", \"glicemia\", n, ignore.case=T)\n  if (unique) n <- make.unique(n, sep = \"_\")\n  if (is.data.frame(.data)) {\n    colnames(.data) <- n\n    .data\n  } else {\n    n\n  }\n}\n\n\ndata_clean <- clinical_names(data_fixed)\n\ncomparison <- cbind(data.frame((colnames(data))),\n                        data.frame((colnames(data_fixed))),\n                        data.frame((colnames(data_clean))))\n\ncolnames(comparison) <- c(\"original\",\"fixed\",\"clean\") \n\ncomparison\n\n           original             fixed             clean\n1          paziente          paziente          paziente\n2               età               eta               eta\n3               SEX               sex               sex\n4          diagnosi          diagnosi          diagnosi\n5           terapia           terapia           terapia\n6             tempo             tempo             tempo\n7            Cvrisk            cvrisk            CVrisk\n8              peso              peso              peso\n9        delta Peso        delta_peso        delta_peso\n10              BMI               bmi               bmi\n11         deltaBMI         delta_bmi         delta_bmi\n12              PAS               pas               PAS\n13         deltaPas         delta_pas         delta_PAS\n14              pad               pad               PAD\n15         deltaPad         delta_pad         delta_PAD\n16              HBO               hbo               HBO\n17           neutro            neutro            neutro\n18            linfo             linfo             linfo\n19             glic              glic          glicemia\n20    deltaglicemia     deltaglicemia     deltaglicemia\n21            HBAC1             hbac1             HbA1C\n22       deltaHbAc1      delta_hb_ac1       delta_HbA1C\n23            sodio             sodio             sodio\n24         potassio          potassio          potassio\n25           calcio            calcio            calcio\n26          fosforo           fosforo           fosforo\n27      colesterolo       colesterolo       colesterolo\n28 deltaColesterolo delta_colesterolo delta_colesterolo\n29              HDL               hdl               HDL\n30         deltaHDL         delta_hdl         delta_HDL\n31              ldl               ldl               LDL\n32         deltaLDL         delta_ldl         delta_LDL\n33               TG                tg                tg\n34          deltaTG          delta_tg          delta_tg\n35             ACTH              acth              ACTH\n36        cortisolo         cortisolo         cortisolo\n37              CLU               clu               CLU\n38              IGF               igf               IGF\n39              TSH               tsh               TSH\n40              fT4              f_t4               fT4\n41              PTH               pth               PTH\n42       Vitamina D        vitamina_d        vitamina_d\n43          dose_CA           dose_ca           dose_ca\n44          dose_HC           dose_hc           dose_hc\n45          dose_PL           dose_pl           dose_pl\n46 dose equivalente  dose_equivalente  dose_equivalente\n\n\n\n\n\n\nReferences\n\nFirke, Sam. 2023. “Janitor: Simple Tools for Examining and Cleaning Dirty Data.” https://CRAN.R-project.org/package=janitor.\n\n\nMüller, Kirill. 2020. “Here: A Simpler Way to Find Your Files.” https://CRAN.R-project.org/package=here."
  },
  {
    "objectID": "posts/Tip03/index.html",
    "href": "posts/Tip03/index.html",
    "title": "Tip 3: Functions for simulating data",
    "section": "",
    "text": "Summary\n\nExample create variables using runif and rnorm\nWriting a function that wraps all\n\n\nlibrary(data.table)\nx_min   <- 0\nx_max   <- 10   \nx_step  <- 0.01\n\ny_mean  <- 0.5\ny_sd    <- 0.25\ny_min   <- -1\ny_max   <- 1   \n\nx       <- seq(x_min,x_max,x_step)\nvar_random  <- runif(x,y_min,y_max)\nvar_norm    <- rnorm(x,y_mean,y_sd) \n\ndf  <- data.frame (x,var_random,var_norm)\ndt  <- data.table(df)\n\n\nsimpleDataset <- function(number_of_rows,means,sds)\n{\nl <- length(means)\nres <- lapply(seq(1:l),function(x) \n       eval(\n       parse(\n       text=paste(\"rnorm(\",number_of_rows,\",\",means[x],\",\",sds[x],\")\",sep=\"\"))\n       )\n       ) \ndat <- data.frame((sapply(res,c)))\nid <- rownames(dat)\ndat <-  cbind(id=id,dat)\ndt <- data.table(dat)\nreturn(dt)\n}\n\nTesting if everything works\n\ndat1 <- simpleDataset(number_of_rows=3,\n                      means=runif(10,100,150),\n                      sds=runif(10,10,40))\noutliers <- simpleDataset(number_of_rows=5,\n                      means=runif(10,60,80),\n                      sds=runif(10,10,10))                \n\ndato     <-rbind(dat1,outliers) \ndt.melt <- melt(dat1, id.vars=\"id\")\ncolnames(dt.melt) <- c(\"id\",\"category\",\"var1\")\ndt.melt$ncat <- as.numeric(dt.melt$category)\n\ndt.melt\n\n    id category      var1 ncat\n 1:  1       X1 123.01305    1\n 2:  2       X1 102.69608    1\n 3:  3       X1 114.02946    1\n 4:  1       X2  77.07511    2\n 5:  2       X2  62.75087    2\n 6:  3       X2 124.73378    2\n 7:  1       X3 118.91208    3\n 8:  2       X3  83.63316    3\n 9:  3       X3 141.73003    3\n10:  1       X4 131.29628    4\n11:  2       X4  69.80004    4\n12:  3       X4 133.80721    4\n13:  1       X5 171.56729    5\n14:  2       X5 149.64422    5\n15:  3       X5 165.58390    5\n16:  1       X6 162.10209    6\n17:  2       X6 140.87103    6\n18:  3       X6 109.07019    6\n19:  1       X7 210.71200    7\n20:  2       X7 113.92909    7\n21:  3       X7 156.54933    7\n22:  1       X8 144.21891    8\n23:  2       X8 203.81033    8\n24:  3       X8 209.10598    8\n25:  1       X9 124.62854    9\n26:  2       X9 142.83655    9\n27:  3       X9 121.33900    9\n28:  1      X10 120.45884   10\n29:  2      X10 111.04935   10\n30:  3      X10 111.40304   10\n    id category      var1 ncat\n\nstr(dt.melt)\n\nClasses 'data.table' and 'data.frame':  30 obs. of  4 variables:\n $ id      : chr  \"1\" \"2\" \"3\" \"1\" ...\n $ category: Factor w/ 10 levels \"X1\",\"X2\",\"X3\",..: 1 1 1 2 2 2 3 3 3 4 ...\n $ var1    : num  123 102.7 114 77.1 62.8 ...\n $ ncat    : num  1 1 1 2 2 2 3 3 3 4 ...\n - attr(*, \".internal.selfref\")=<externalptr>"
  }
]