[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fun with data",
    "section": "",
    "text": "Tip 4: boxplots and scatterplots: simple recipes\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\nggplot\n\n\nvisualization\n\n\nrecipes\n\n\n\n\n\n\n\n\n\n\n\nMar 11, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\n\n\nTip 3: Functions for simulating data\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nMar 4, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\n\n\nTip 1: ggplot loops\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nFeb 19, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\n\n\nTip 2: Cleaning column names of an imported csv\n\n\n\n\n\n\n\nR\n\n\ntutorials\n\n\n\n\n\n\n\n\n\n\n\nFeb 19, 2023\n\n\nGiorgio Luciano\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a Chemist that works as a researcher at the National Research Council of Italy. I work on characterization of materials and data analysis. I code in Python and R and I like Computer Graphics and Illustration\nAbout this blog\nin this blog I share the code that I write in my everyday work and also fun stuff that I find on other blogs and site about data analytics"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "docs/posts/R Packages/index.html",
    "href": "docs/posts/R Packages/index.html",
    "title": "Fun with Data",
    "section": "",
    "text": "Don’t trust boxplot\n\ncategories: [r,ggplot,recipes]\n\n\n# Author: Giorgio Luciano\n# Title: boxplot fun\n# Date: 16/2/2023\n# Status: checked working\n##---------------------------------------------------------------\n\n# Step 1: Load libraries\n\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(data.table)\nlibrary(RColorBrewer)\nlibrary(ggpubr)\nlibrary(rstatix, warn.conflicts = FALSE)\nlibrary(ggrepel)\nlibrary(ggpubr)\nlibrary(patchwork)\n\n# Step 2: Write a function for generating data with custom number of rows, means and sds\n\nsimpleDataset <- function(number_of_rows, means, sds)\n{\nl <- length( means )\nres <- lapply(seq(1:l),function(x) \n       eval(parse(text=paste(\"rnorm(\",number_of_rows,\",\",means[x],\",\",sds[x],\")\",sep = \"\")))) \ndat <- data.frame((sapply(res,c)))\nid <- rownames(dat)\ndat <-  cbind(id = id,dat)\ndt <- data.table(dat)\nreturn(dt)\n}\n\ndat1 <- simpleDataset(number_of_rows=100,\n                      means = runif(10,100,150),\n                      sds = runif(10,10,40))\n\noutliers <- simpleDataset(number_of_rows=5,\n                      means = runif(10,60,80),\n                      sds = runif(10,10,10))                  \n\ndato     <-rbind(dat1,outliers) \n\ndt.melt <- melt(dat1, id.vars=\"id\")\ncolnames(dt.melt) <- c(\"id\",\"category\",\"var1\")\ndt.melt$ncat <- as.numeric(dt.melt$category)\n\n#Step 3:    Jiitter plots + boxplot + brackets \n\n#setting up dimensions\noptions(repr.plot.width=8.9, repr.plot.height=8.9,units=\"cm\")\n\n#adding jiitter plot\n\np <-  ggplot(dt.melt,aes(x=factor(ncat),y=var1))        +\n      geom_jitter(position = position_jitter(0.15),alpha=0.5,size = 3) +\n      geom_boxplot(alpha = 0,lwd=0.2) \n##---------------------------------------------------------------\n\nSo for now everything on track. We created a dataset using a custom function. 10 variables with 100 points each and them we plot them using scatter plots. Before plotting a few more data we need to answer the question\n*How are boxplot constructed?* (*warning*: shameless self-promotion ahead) First of all you can check on my book/ebook [https://amzn.com/B08W8W5WSF](https://amzn.com/B08W8W5WSF)\nNow it starts the fun part we will recreate a plot on the anatomy of a boxplot (see [here](https://www.sharpsightlabs.com/blog/ggplot-boxplot/)) using ggplot.\n\n# we create a dataset and add a few outliers\n# \ny   <- c(60,63,105,155,rnorm(100,80,25))\nbox <-  ggplot()                                               +\n        theme_void()                                           +\n        geom_boxplot(aes(x=0,y=y),width=1,notch = FALSE,lwd=1) +  \n        theme(legend.position = \"none\")                        +\n        lims( x = c(-2,2) )\n      \n#how can we  get out data? using the function ggplot_build()\n#need to change it to a data.frame and rename cols\n\nbox_data <- (ggplot_build(box)$data)[[1]]\nbox_data\n\n      ymin    lower   middle    upper     ymax outliers notchupper notchlower x\n1 16.81564 58.19611 75.04227 96.32843 130.8743      155   80.95017   69.13436 0\n  flipped_aes PANEL group ymin_final ymax_final xmin xmax xid newx new_width\n1       FALSE     1    -1   16.81564        155 -0.5  0.5   1    0         1\n  weight colour  fill size alpha shape linetype\n1      1 grey20 white    1    NA    19    solid\n\nbdata <- data.frame(t(box_data[c(1,2,3,4,5,14)]))\ncolnames(bdata) <- c(\"y\")\n#we need to transpose the data and convert them to a data frame\n#now we extract the ourliers \noutl  <- data.frame(box_data$outliers)\ncolnames(outl)  <- c(\"outl\")\n\n#now that I got the data I plot everything with labels\np2 <- box + geom_text (data=bdata,aes(\n                      x=1.5,\n                      y=y,\n                      label = c(\"min\",\"Lower Q\",\"Median\",\"Upper Q\",\"max\",\"outliers\")), size = 2)+\n                      geom_segment(data = bdata, aes(x = 0.8, y = y, xend = 0.7, yend = y),lwd=1)  \n                        \n#since we have created the dataset WITH outliers we include labels also for them\n#if your dataset has no outliers you need to commet this part out\n    \np2 + geom_text_repel(data=outl,aes(x=0.1, y=outl,label=format(round(outl, 2), nsmall = 2)),size= 2) \n\n\n\n\n*notes on the code:* we create our variable `y` with `rnorm` and we add a few outliers by hand then we create the boxplot with an empty theme using `theme_void()`. The funny part start when we ask ggplot to show how the plot was built with the `ggplot_build`. We then need to rotate (`t`) the selected columns `c(1,2,3,4,5,14)` ,convert the results into a `data.frame`, rename the columns (`colnames`) and then use them (our `y`) to add labvels to our plot using `geom_text`\nAnother representation of boxplot can also include *notch*. the default is not to visualuize them but just adding `notch=true` to the previous plot we will do the trick\n\nboxnotch <-  ggplot()                                               +\n             theme_void()                                           +\n             geom_boxplot(aes(x=0,y=y),width=1,notch = TRUE,lwd=1)  +  \n             theme(legend.position = \"none\")                        +\n             lims(x=c(-2,4))\nnotchdata <- data.frame(t(box_data[c(7,8)]))\ncolnames(notchdata) <- c(\"y_notch\")\n#we need to transpose the data and convert them to a data frame\n\n#now that I got the data I plot everything with labels\np3 <- boxnotch +  geom_segment(data=notchdata, aes(x = 0.8, \n                                                   y = mean(y_notch),\n                                                   xend = 0.6, yend = y_notch\n                                                   ),lwd=1)\np4 <- p3 + annotate(geom=\"text\", x=2.5, y= mean(notchdata$y_notch),\n                    label=\"notch (95% confidence\\ninterval of median)\",size=4)\np4\n\n\n\n\nok but what if multiple dataset have same statistics? Like in the case of the datasaurus package(Matejka and Fitzmaurice 2017)\n\nlibrary(datasauRus)\n\nWarning: package 'datasauRus' was built under R version 4.2.2\n\nsummary(box_plots)\n\n      left              lines               normal          right       \n Min.   :-9.76964   Min.   :-9.769575   Min.   :-9.76   Min.   :-9.760  \n 1st Qu.:-2.68999   1st Qu.:-2.689993   1st Qu.:-2.68   1st Qu.:-2.680  \n Median :-0.00999   Median :-0.007132   Median : 0.00   Median : 0.000  \n Mean   :-1.17780   Mean   :-0.831733   Mean   : 0.00   Mean   : 1.174  \n 3rd Qu.: 2.67007   3rd Qu.: 2.670236   3rd Qu.: 2.68   3rd Qu.: 2.680  \n Max.   : 9.75025   Max.   : 9.756001   Max.   : 9.76   Max.   : 9.760  \n     split          \n Min.   :-9.769886  \n 1st Qu.:-2.689989  \n Median :-0.003099  \n Mean   :-0.003060  \n 3rd Qu.: 2.680000  \n Max.   : 9.760000  \n\np1 <-ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_jitter(alpha=0.05)                                 +\ntheme_void()  \n\np2 <- ggplot(stack(box_plots), aes(x = ind, y = values))+\ngeom_boxplot(lwd=0.05) +\ntheme_void()  \np1+p2\n\n\n\n\nWe can see that plotting the raw points even for hundreds of points works and represent well our data. In this case adding notch does not solve the problem. Other kind of plot get not fooled by our data as it can be seen in the following figure:\n\npnotch <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_boxplot(notch=TRUE)  +  ggtitle(\"(notch=TRUE)\")\n  \npjitter <-ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_jitter(alpha=0.05)  +  ggtitle(\"geom_jitter\") \n\npviolin <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_violin(lwd=1)  +  ggtitle(\"geom_violin\") \n\npnotch \n\n\n\npjitter \n\n\n\npviolin\n\n\n\n\nOther packages\n1. beeswarm plot ggbeeswarm [https://github.com/eclarke/ggbeeswarm] (and here the things start getting artistic too!) (note: not all representation for this dataset work due to the number of points)\n\nlibrary(ggbeeswarm)\n\nWarning: package 'ggbeeswarm' was built under R version 4.2.2\n\np_qrandom0 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05)  +  ggtitle(\"quasi_random\") \n\n#p_qrandom0\n\np_qrandom1 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukey\")  +  ggtitle(\"Tukey\") \n\n#p_qrandom1\n\np_qrandom2 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukeyDense\")   +  ggtitle(\"Tukey + density\") \n\n#p_qrandom2\n\np_qrandom3 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"tukeyDense\")   +  ggtitle(\"Banded frowns\") \n\n#p_qrandom3\n\np_qrandom4 <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_quasirandom(alpha=0.05,method = \"frowney\")   +  ggtitle(\"Banded smiles\") \n\n#p_qrandom4\n\n#too many points\n#p_beeswarm <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\n#geom_beeswarm(alpha=0.05) +  ggtitle(\"beeswarm\") \n\np_qrandom0\n\n\n\np_qrandom1\n\n\n\np_qrandom2\n\n\n\n\nyou can halso mix plot a useful package for that is gghalves\n\nlibrary(gghalves)\n\nWarning: package 'gghalves' was built under R version 4.2.2\n\npoint_half <- ggplot(stack(box_plots), aes(x = ind, y = values)) +\ngeom_half_point(alpha=0.05) \n\ngeom_half_violin() \n\ngeom_half_violin: side = l, nudge = 0, draw_quantiles = NULL, na.rm = FALSE\nstat_half_ydensity: trim = TRUE, scale = area, na.rm = FALSE\nposition_dodge \n\npoint_half\n\n\n\n\nfinally a very useful package, also my favorite one for EDA ggstatplotthat you can find here that calculate also a lot of useful stats and combine different kind of plot in one plot\n\nlibrary(ggstatsplot)\n\nYou can cite this package as:\n     Patil, I. (2021). Visualizations with statistical details: The 'ggstatsplot' approach.\n     Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167\n\n\n\nAttaching package: 'ggstatsplot'\n\n\nThe following object is masked from 'package:data.table':\n\n    :=\n\nstackbox <- stack(box_plots)\n\npstack  <- ggbetweenstats(\n  data = stackbox,\n  x = ind,\n  y = values,\n)\npstack \n\n\n\n\n\n\n\n\nReferences\n\nMatejka, Justin, and George Fitzmaurice. 2017. “Same Stats, Different Graphs.” Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems, May. https://doi.org/10.1145/3025453.3025912."
  },
  {
    "objectID": "posts/Tip01/index.html",
    "href": "posts/Tip01/index.html",
    "title": "Tip 1: ggplot loops",
    "section": "",
    "text": "Summary\n\nCreate an empty list\nPopulate your list with objects (ggplots)\nCreate iteratively names for the objects\nRename the objects inside the list using the name list generated previously\nShow all plots using wrap_plots\n\nInstead of using boring plots we will use our private art collections and items.\nOne great package to create your art in R is aRtsy Let’s fire it up\n\nrequire(aRtsy)\n\nLoading required package: aRtsy\n\n\nWarning: package 'aRtsy' was built under R version 4.2.2\n\nrequire(patchwork)\n\nLoading required package: patchwork\n\n\n\n#before starting for having a look at the palette \n?colorPalette\n\nstarting httpd help server ... done\n\n\nCreate a Mondrian and save it\n\nset.seed(23)\nComposition_10 <- canvas_squares(colors = colorPalette(\"boogy2\"))\nsaveCanvas(Composition_10 , filename = \"Mondrian.png\")\nComposition_10 \n\n\n\n\nand another one\n\nset.seed(1)\naspect_ratio <- 1\nheight <- 2\nComposition_1 = canvas_segments(colors = colorPalette(\"blackwhite\"))\nComposition_1 \n\n\n\n\nor if you want to create a lots of them, create names automatically and then take a look at just one of your artistic composition in your collection use the following code:\n\nn_items <- 3\ncollection <- list()\nname_of_Composition  <- list()\nfor (i in 1:n_items) {\n  seed <-  (sample(1:100000,1)) + 1\n  name_of_Composition[[i]] <- paste0(\"Composition_\", i)\n  collection[[i]] <- canvas_squares(colors = colorPalette(\"boogy2\"))\n  \n}\nnames(collection) <- name_of_Composition\n\ncollection\n\n$Composition_1\n\n\n\n\n\n\n$Composition_2\n\n\n\n\n\n\n$Composition_3\n\n\n\n\n\n\n#as you can notice the setting for figure output in this chunk was changed in order to showplots with a rato of 3:1\nwrap_plots(collection)\n\n\n\n\n(Pedersen 2022) [Wickham (2016)](Derks 2022)\n\n\n\n\nReferences\n\nDerks, Koen. 2022. “aRtsy: Generative Art with ’Ggplot2’.” https://CRAN.R-project.org/package=aRtsy.\n\n\nPedersen, Thomas Lin. 2022. “Patchwork: The Composer of Plots.” https://CRAN.R-project.org/package=patchwork.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org."
  },
  {
    "objectID": "posts/Tip02/index.html",
    "href": "posts/Tip02/index.html",
    "title": "Tip 2: Cleaning column names of an imported csv",
    "section": "",
    "text": "Summary\n\nImport data from a csv file\nUse the function clean_names from (Firke 2023)j R function\nWrite a function in base using gsub and regex to tackle specific issues\nYou’re done\n\nFirst of all we import the csv using the library (Müller 2020)here\n\nlibrary(here)\n\nWarning: package 'here' was built under R version 4.2.2\n\n\nhere() starts at D:/giorgioluciano.github.io\n\nfile_in <- \"FakeData.csv\"\npath_in <- \"posts/Tip02/\"\ndata <- read.csv(here(path_in,file_in), head=T, check.names=F, encoding=\"latin1\")\n\n\nlibrary(janitor)\n\nWarning: package 'janitor' was built under R version 4.2.2\n\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\ndata_fixed <- clean_names(data)\n\nAnd now the function written by William Doane\n\nclinical_names <- function(.data, unique = FALSE) {\n  n <- if (is.data.frame(.data)) colnames(.data) else .data\n  n <- gsub(\"cvrisk\", \"CVrisk\", n , ignore.case=T)\n  n <- gsub(\"hbo\", \"HBO\", n , ignore.case=T)\n  n <- gsub(\"ft4\", \"fT4\", n , ignore.case=T)\n  n <- gsub(\"f_t4\", \"fT4\", n , ignore.case=T)\n  n <- gsub(\"ft3\", \"fT3\", n , ignore.case=T)\n  n <- gsub(\"f_t3\", \"fT3\", n , ignore.case=T)\n  n <- gsub(\"ldl\", \"LDL\", n , ignore.case=T)\n  n <- gsub(\"hdl\", \"HDL\", n , ignore.case=T)\n  n <- gsub(\"hba1c\", \"HbA1C\", n, ignore.case=T)\n  n <- gsub(\"hbac1\", \"HbA1C\", n, ignore.case=T)\n  n <- gsub(\"hb_ac1\", \"HbA1C\",n,ignore.case=T)\n  n <- gsub(\"\\\\igf\\\\b\", \"IGF\", n , ignore.case=T)\n  n <- gsub(\"tsh\", \"TSH\", n , ignore.case=T)\n  n <- gsub(\"acth\", \"ACTH\", n, ignore.case=T)\n  n <- gsub(\"\\\\Na\\\\b\", \"Sodio\", n)\n  n <- gsub(\"\\\\K\\\\b\",  \"Potassio\", n)\n  n <- gsub(\"\\\\P\\\\b\",  \"Fosforo\", n)\n  n <- gsub(\"\\\\pas\\\\b\", \"PAS\", n, ignore.case=T)\n  n <- gsub(\"\\\\pad\\\\b\", \"PAD\", n, ignore.case=T)\n  n <- gsub(\"\\\\pth\\\\b\", \"PTH\", n, ignore.case=T)\n  n <- gsub(\"\\\\clu\\\\b\", \"CLU\", n, ignore.case=T)\n  n <- gsub(\"\\\\tg\\\\b\", \"TG\", n, ignore.case=T)\n  n <- gsub(\"\\\\glic\\\\b\", \"glicemia\", n, ignore.case=T)\n  if (unique) n <- make.unique(n, sep = \"_\")\n  if (is.data.frame(.data)) {\n    colnames(.data) <- n\n    .data\n  } else {\n    n\n  }\n}\n\n\ndata_clean <- clinical_names(data_fixed)\n\ncomparison <- cbind(data.frame((colnames(data))),\n                        data.frame((colnames(data_fixed))),\n                        data.frame((colnames(data_clean))))\n\ncolnames(comparison) <- c(\"original\",\"fixed\",\"clean\") \n\ncomparison\n\n           original             fixed             clean\n1          paziente          paziente          paziente\n2               età               eta               eta\n3               SEX               sex               sex\n4          diagnosi          diagnosi          diagnosi\n5           terapia           terapia           terapia\n6             tempo             tempo             tempo\n7            Cvrisk            cvrisk            CVrisk\n8              peso              peso              peso\n9        delta Peso        delta_peso        delta_peso\n10              BMI               bmi               bmi\n11         deltaBMI         delta_bmi         delta_bmi\n12              PAS               pas               PAS\n13         deltaPas         delta_pas         delta_PAS\n14              pad               pad               PAD\n15         deltaPad         delta_pad         delta_PAD\n16              HBO               hbo               HBO\n17           neutro            neutro            neutro\n18            linfo             linfo             linfo\n19             glic              glic          glicemia\n20    deltaglicemia     deltaglicemia     deltaglicemia\n21            HBAC1             hbac1             HbA1C\n22       deltaHbAc1      delta_hb_ac1       delta_HbA1C\n23            sodio             sodio             sodio\n24         potassio          potassio          potassio\n25           calcio            calcio            calcio\n26          fosforo           fosforo           fosforo\n27      colesterolo       colesterolo       colesterolo\n28 deltaColesterolo delta_colesterolo delta_colesterolo\n29              HDL               hdl               HDL\n30         deltaHDL         delta_hdl         delta_HDL\n31              ldl               ldl               LDL\n32         deltaLDL         delta_ldl         delta_LDL\n33               TG                tg                tg\n34          deltaTG          delta_tg          delta_tg\n35             ACTH              acth              ACTH\n36        cortisolo         cortisolo         cortisolo\n37              CLU               clu               CLU\n38              IGF               igf               IGF\n39              TSH               tsh               TSH\n40              fT4              f_t4               fT4\n41              PTH               pth               PTH\n42       Vitamina D        vitamina_d        vitamina_d\n43          dose_CA           dose_ca           dose_ca\n44          dose_HC           dose_hc           dose_hc\n45          dose_PL           dose_pl           dose_pl\n46 dose equivalente  dose_equivalente  dose_equivalente\n\n\n\n\n\n\nReferences\n\nFirke, Sam. 2023. “Janitor: Simple Tools for Examining and Cleaning Dirty Data.” https://CRAN.R-project.org/package=janitor.\n\n\nMüller, Kirill. 2020. “Here: A Simpler Way to Find Your Files.” https://CRAN.R-project.org/package=here."
  },
  {
    "objectID": "posts/Tip03/index.html",
    "href": "posts/Tip03/index.html",
    "title": "Tip 3: Functions for simulating data",
    "section": "",
    "text": "Summary\n\nExample of creating variables using runif and rnorm\nWriting a function that wraps all\n\nFirst of all we use the runif and rnorm to have a look how they work.\n\nlibrary(data.table)\nx_min   <- 0\nx_max   <- 10   \nx_step  <- 0.01\n\ny_mean  <- 0.5\ny_sd    <- 0.25\ny_min   <- -1\ny_max   <- 1   \n\nx       <- seq(x_min,x_max,x_step)\nvar_random  <- runif(x,y_min,y_max)\nvar_norm    <- rnorm(x,y_mean,y_sd) \n\ndf  <- data.frame (x,var_random,var_norm)\ndt  <- data.table(df)\n\n\nsimpleDataset <- function(number_of_rows,means,sds)\n{\nl <- length(means)\nres <- lapply(seq(1:l),function(x) \n       eval(\n       parse(\n       text=paste(\"rnorm(\",number_of_rows,\",\",means[x],\",\",sds[x],\")\",sep=\"\"))\n       )\n       ) \ndat <- data.frame((sapply(res,c)))\nid <- rownames(dat)\ndat <-  cbind(id=id,dat)\ndt <- data.table(dat)\nreturn(dt)\n}\n\nExample: We simulate the values of the LDL cholesterol of 2 patients in 3 different times. The first one patient (X1) has an average value of 200 of LDL with a standard variation of 2 while the second (X2) has an average of 150 with a standard deviation of 10. Note: All values are expressed in mg/dL\n\ndataset1 <- simpleDataset(3,c(200,180),c(2,10))\ndataset1\n\n   id       X1       X2\n1:  1 200.6442 196.5358\n2:  2 200.6801 166.5065\n3:  3 200.4200 196.2089\n\n\nExample: this time we combine runif and simpleDataset. We simulate the values of the LDL cholesterol of 5 patients in 7 different times. The values for each patient are between a min = 100 and a max = 150 with a standard deviation between a min sd = 10 and max sd = 40. We also simulate two time that presents outliers values between a min = 180 and max = 200 and an min sd = 10 and max sd = 40 . We merge the values for each patient (7 times + 2 outliers times) and finally we use the function melt to reshape the dataset.\n\ndat1 <- simpleDataset(number_of_rows=7,\n                      means=runif(5,100,150),\n                      sds=runif(5,10,40))\noutliers <- simpleDataset(number_of_rows=2,\n                      means=runif(5,180,200),\n                      sds=runif(5,10,40))                 \n\ndat1\n\n   id        X1       X2        X3        X4       X5\n1:  1  97.92524 105.5036 110.66623  34.45252 108.1226\n2:  2 169.96962 136.5666  97.62086 -11.68481 135.7269\n3:  3  77.46899 135.7573  93.37948 133.03592 129.4088\n4:  4 197.75026 168.3904 132.91647 154.98579 164.1461\n5:  5 121.99923 140.2879 127.80267 165.29857 158.9153\n6:  6 176.63684 127.6318 107.84311 138.62779 157.1849\n7:  7 117.90619 176.1431  99.01017 166.91662 219.9138\n\noutliers\n\n   id       X1       X2       X3       X4       X5\n1:  1 202.0947 191.3382 138.8483 194.0729 207.0543\n2:  2 194.0590 196.3606 209.5827 248.9402 175.0254\n\ndato     <-rbind(dat1,outliers) \ndt.melt <- melt(dat1, id.vars=\"id\")\ncolnames(dt.melt) <- c(\"id\",\"category\",\"var1\")\ndt.melt$ncat <- as.numeric(dt.melt$category)\n\ndt.melt\n\n    id category      var1 ncat\n 1:  1       X1  97.92524    1\n 2:  2       X1 169.96962    1\n 3:  3       X1  77.46899    1\n 4:  4       X1 197.75026    1\n 5:  5       X1 121.99923    1\n 6:  6       X1 176.63684    1\n 7:  7       X1 117.90619    1\n 8:  1       X2 105.50360    2\n 9:  2       X2 136.56661    2\n10:  3       X2 135.75728    2\n11:  4       X2 168.39042    2\n12:  5       X2 140.28791    2\n13:  6       X2 127.63183    2\n14:  7       X2 176.14312    2\n15:  1       X3 110.66623    3\n16:  2       X3  97.62086    3\n17:  3       X3  93.37948    3\n18:  4       X3 132.91647    3\n19:  5       X3 127.80267    3\n20:  6       X3 107.84311    3\n21:  7       X3  99.01017    3\n22:  1       X4  34.45252    4\n23:  2       X4 -11.68481    4\n24:  3       X4 133.03592    4\n25:  4       X4 154.98579    4\n26:  5       X4 165.29857    4\n27:  6       X4 138.62779    4\n28:  7       X4 166.91662    4\n29:  1       X5 108.12259    5\n30:  2       X5 135.72688    5\n31:  3       X5 129.40880    5\n32:  4       X5 164.14611    5\n33:  5       X5 158.91531    5\n34:  6       X5 157.18490    5\n35:  7       X5 219.91383    5\n    id category      var1 ncat\n\nstr(dt.melt)\n\nClasses 'data.table' and 'data.frame':  35 obs. of  4 variables:\n $ id      : chr  \"1\" \"2\" \"3\" \"4\" ...\n $ category: Factor w/ 5 levels \"X1\",\"X2\",\"X3\",..: 1 1 1 1 1 1 1 2 2 2 ...\n $ var1    : num  97.9 170 77.5 197.8 122 ...\n $ ncat    : num  1 1 1 1 1 1 1 2 2 2 ...\n - attr(*, \".internal.selfref\")=<externalptr>"
  },
  {
    "objectID": "posts/Tip04/index.html",
    "href": "posts/Tip04/index.html",
    "title": "Tip 4: boxplots and scatterplots: simple recipes",
    "section": "",
    "text": "Summary\n\nSimulate data, check and assign data types\nCreate a scatterplot with ggplot\nCreate violin plot with ggstatsplot\n\nExample 1 we want to visualize the difference between two groups of patients that follow two different diets. Group A has an average of total cholesterol of 180 with a standard deviation of 20 while Group B and average of 200 with a standard deviation of 40\n\nlibrary(MASS)\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.2.2\n\nlibrary(data.table)\n\n\nnpatientsA <- 500\nnpatientsB <- 520\ncholA <- mvrnorm(n=npatientsA, mu=180, Sigma=20, empirical=T)\ncholB <- mvrnorm(n=npatientsB, mu=200, Sigma=40, empirical=T)\n\ndataA <- cbind(cholA,rep(\"A\",npatientsA))  \ndataB <- cbind(cholB,rep(\"B\",npatientsB))  \n\ndata <- data.frame(rbind(dataA,dataB))\ncolnames(data) <- c(\"Cholesterol\",\"group\")\ndata$Cholesterol <- as.numeric(data$Cholesterol)\n\np1 <-ggplot(data, aes(x = group, y = Cholesterol)) + geom_jitter(alpha=0.05) \n\na few observation on the code. First of all, we need to input the data in a data.frame otherwise ggplot will give us an error. the second observation is that since we put chr labels on our groups we needed to define Cholesterol as.numeric in order to avoid strange results. Try to comment the line data$Cholesterol <- as.numeric(data$Cholesterol) and you can see by yourself what will happen. (hint: a “labelstorm!”)\nThis very simple plot is one of my favorite. It let you see the raw data and immediately understand the distribution of your data and also avoid the pitfall of boxplot (see (Matejka and Fitzmaurice 2017))\nIf you need inferential statistics on your data another resource is (Patil 2021). See the following example with our data. NOTE that we nee to transform the group label as.factor\n\nlibrary(ggstatsplot)\n\nYou can cite this package as:\n     Patil, I. (2021). Visualizations with statistical details: The 'ggstatsplot' approach.\n     Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167\n\n\n\nAttaching package: 'ggstatsplot'\n\n\nThe following object is masked from 'package:data.table':\n\n    :=\n\ndata$group <- as.factor(data$group)\n\npstack  <- ggbetweenstats(data,group,Cholesterol)\n                          \npstack    \n\n\n\n\n\n\n\n\nReferences\n\nMatejka, Justin, and George Fitzmaurice. 2017. “Same Stats, Different Graphs.” Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems, May. https://doi.org/10.1145/3025453.3025912.\n\n\nPatil, Indrajeet. 2021. “Visualizations with Statistical Details: The ’Ggstatsplot’ Approach” 6: 3167. https://doi.org/10.21105/joss.03167."
  }
]